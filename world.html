<!doctype html>

<html>

<head>

  <title>osu!!</title>
  <script src="rigidbody2D.js"></script>
  <script src="boxCollider2D.js"></script>
</head>
<meta charset="UTF-8">

<body>
  <div id="canvasContainer">
    <canvas id="gameCanvas" width="500" height="500">
      <script>
        var canvas, ctx;
        window.onload = function() { //runs when the page loads
          canvas = document.getElementById("gameCanvas");
          ctx = canvas.getContext('2d');
          document.addEventListener("keydown", function (evt) {
            mainloop();
            if(evt.keyCode == UPKEY){
              vertical = 1;
              console.log(vertical);
            }
            if(evt.keyCode == DOWNKEY){
              vertical = -1;
            }
            if(evt.keyCode == LEFTKEY){
              horisontal = 1;
            }
            if(evt.keyCode == RIGHTKEY){
              horisontal = -1;
            }

          });
          document.addEventListener("keyup", function (evt) {
            if(evt.keyCode == UPKEY  && vertical !== -1 || evt.keyCode == DOWNKEY && vertical !== 1){
              vertical = 0;
            }
            if(evt.keyCode == LEFTKEY && horisontal !== -1 || evt.keyCode == RIGHTKEY && horisontal !== 1){
              horisontal = 0;
            }
          });

          // setInterval(mainloop, 1000 / framesPerSecond); //runs the canvas
          blocks.push(new rigidBody(0.5,0.5,1,1,1,0,2.2));
          // boxColliders.push(new boxCollider(0.5,10,10,2,0.3));
        } //func end
        // var nextbloontime = 1000;
        // var bloontimercount = 0;
        // mainloop(){
        //   if (bloontimercount >= nextbloontime){
        //     if(bloon == "blue"){
        //       nextbloontime = 2000;
        //     }
        //   }else{
        //     bloontimercount += 1000/framesPerSecond;
        //   }

        // }
        // var time = 1000;
        // function amkebloons(){
        //   console.log("yes")
        //   setTimeout(amkebloons(),1000);
        // }
        // function nextone(){
        //   // setTimeout(amkebloons(),1000);
        // }
        
        function mainloop() { //mainloop
          colourRect(0,0, canvas.width, canvas.height, "rgb(50,50,50,1)"); //background
          grid();
          drawline(...line.pos1,...line.pos2);
          anglefromgrad(...line.pos1,...line.pos2);
          console.log(similtaniouseY(returnYIntercept(...line.pos1,gradientssmooth(...line.pos1,...line.pos2)),returnYIntercept(10,10,1),gradientssmooth(...line.pos1,...line.pos2),1));
          boxColliders.forEach(function (block) {
            block.setAngle();
            block.draw();
            // blocks.draw();
          });
          blocks.forEach(function (block,i) {
            block.physics();
            block.draw();
            // blocks.draw();
          });
          camera();
        };
        function collisionBetweenlinesXorY(xory = "x", ){

        }


        function returnX2(y,c,m,c2,m2){
        //y=mx+c
        //x = y-c/m
        if (Math.abs(m) >0){
          return Math.tan(Math.atan((y-c)/m));
        }
        return Math.tan(Math.atan((y-c2)/m2));
        
        }
        function gradientssmooth(x1,y1,x2,y2){
          return Math.tan(Math.atan((y2-y1)/(x2-x1)))
        }



        function returnXorYchange(xory,m,c){
          // c = sqrt( a^2 + b^2 ) a:b = gradient:1   a = b*gradient | c = sqrt(b^2 + (b * gradient)^2)
          // c^2 = 2b2m2
          // b = sqrt(c^2/m^2)/2 
          // a = sqrt(c^2 - b^2)
          let b = Math.sqrt(Math.pow(c,2)/Math.pow(m,2))/2;
          if (xory.toLowerCase() == "x"){
            // console.log("run")
            return b;
          }
          return Math.sqrt(Math.pow(c,2) - Math.pow(b,2));
        }
        function trigH(o,a){
          return Math.sqrt(Math.pow(o,2) + Math.pow(a,2));
        }

        function returnAngleFromGrad(rise,run){
          let angle = Math.atan(rise/run);
          if (run < 0){
            angle += 180;
          }else if (rise < 0) {
            angle += 360;
          }
        }
        
        // function similtaniouseX(x1,c1,c2,m1,m2){
        //   return (c1-c2+(m1*x1))/m2;
        // }
        function collisionsbetweenline(line1x1,line1y1,line1x2,line1y2,line2x1,line2y1,line2x2,line2y2){
        // gradientssmooth(x1,y1,x2,y2)
        //line1
        let gradient1 = gradientssmooth(line1x1,line1y1,line1x2,line1y2);
        let yintersect1 = returnYIntercept(line1x1,line1y1,gradient1);
        //line2
        let gradient2 = gradientssmooth(line2x1,line2y1,line2x2,line2y2);
        let yintersect2 = returnYIntercept(line2x1,line2y1,gradient2);
        //similtaniouseY(c1,c2,m1,m2)
        let y1 = similtaniouseY(yintersect1,yintersect2,gradient1,gradient2);
        if(Math.abs(gradient1) >= 1){
            return (y1 >= smallest(line1y1,line1y2) && y1 <= biggest(line1y1,line1y2));
        }else{//y = mx+c | x = (y-c)/m
            let x1;
            if(Math.abs(gradient1) > 0){
                x1 = (y1-yintersect1)/gradient1;
            }else{
                x1 = (y1-yintersect2)/gradient2;
            }
            return (x1 >= smallest(line1x1,line1x2) && x1 <= biggest(line1x1,line1x2));
        }
    }













        function similtaniouseY(c1,c2,m1,m2){
          return ((c2*Math.tan(Math.atan(-m1/-m2)))-c1)/(Math.tan(Math.atan(-m1/-m2))-1);
        }

        function biggest(points){
          let highestp = points[0];
            for(let i = 1; i < points.length;i++){
              if (highestp <= points[i]){
                highestp = points[i];
              }
            }
            return highestp;
        }
        function smallest(points){
            let smallestp = points[0];
            for(let i = 1; i < points.length;i++){
                if (smallestp >= points[i]){
                    smallestp = points[i];
                }
            }
            return smallestp;
        }

        // function returnGradient(pos1x,pos1y,pos2x,pos2y){
        //   //rise/run
        //   //pos2y-pos1y/pos2x-pos1x
          
        //   if((pos2x-pos1x) == 0){
        //     return "vertical";
        //   }else if((pos2y-pos1y) == 0){
        //     return "horizontal";
        //   }
        //   return ((pos2y-pos1y)/(pos2x-pos1x));

        // }
        function returnYIntercept(x,y,gradient){
          //y-mx = c
          return (y-(gradient*x));
        }

        var framesPerSecond = 60; 
        var blocks = [];
        var boxColliders = [];

        var cameraOffset = {
          x : 0,
          y : 0,
          scale : 20
        };
        const UPKEY = 87;
        const DOWNKEY = 83;
        const LEFTKEY = 65;
        const RIGHTKEY = 68;
        var vertical = 0;
        var horisontal = 0;
        var cameraspeed = 0.1;
        var line = {
          pos1 : [5,-5],
          pos2 : [5,5]
        };

        function drawline(x1,y1,x2,y2,colour = "rgba(255,255,255,1)"){
          ctx.strokeStyle = colour;
          ctx.linewidth = 0.02*cameraOffset.scale;
          ctx.beginPath();
          ctx.moveTo(X(x1),Y(y1));
          ctx.lineTo(X(x2),Y(y2));
          ctx.stroke();
        };

        function grid(){
          for (let i = -100; i < 100; i++){
            // (x1,y1,x2,y2,x3,y3,x4,y4,colour = "rgba(100,100,100,1)",borderwidth = 0,bordercolour = "rgba(0,0,0,0)")
            // drawSquare(-i,-i,i,-i,i,i,-i,i,"rgba(0,0,0,0)",0.02,"rgba(255,255,255,1)");
            ctx.strokeStyle = "rgba(255,255,255,1)";
            ctx.lineWidth = 0.02*cameraOffset.scale;
            ctx.beginPath()
            ctx.moveTo(X(100),Y(i));
            ctx.lineTo(X(-100),Y(i));
            ctx.moveTo(X(i),Y(100));
            ctx.lineTo(X(i),Y(-100));
            ctx.stroke();
          }
          ctx.strokeStyle = "rgba(0,0,0,1)";
          ctx.lineWidth = 0.04*cameraOffset.scale;
          ctx.beginPath()
          ctx.moveTo(X(100),Y(0));
          ctx.lineTo(X(-100),Y(0));
          ctx.moveTo(X(0),Y(100));
          ctx.lineTo(X(0),Y(-100));
          ctx.stroke();
          // console.log(X(1))
        }
        function X(xpos){
          return ((xpos + cameraOffset.x)*cameraOffset.scale + canvas.width/2);
        }
        function Y(ypos){
          return ((ypos + cameraOffset.y)*cameraOffset.scale + canvas.height/2);
        }
        function colourRect(x, y, w, h, c) {
          ctx.fillStyle = c;
          ctx.fillRect(x, y, w, h)
        }
        
        function camera(){
            cameraOffset.x += cameraspeed*horisontal;
            cameraOffset.y += cameraspeed*vertical;
        }
        function rotate(worldx,worldy,width,height,finalAngle){
          let x = worldx + Math.cos(finalAngle)*Math.sqrt(Math.pow(width/2,2)+Math.pow(height/2,2));
          let y = worldy + Math.sin(finalAngle)*Math.sqrt(Math.pow(width/2,2)+Math.pow(height/2,2));
          return [x,y];
        }
        function returnDistanceBetweenIntercepts(pos1,grad1,grad2,intercept2){
          return Math.sqrt(Math.pow(pos1[0]-returnX2(similtaniouseY(returnYIntercept(...pos1,grad1),intercept2,grad1,grad2),intercept2,grad2,grad1,returnYIntercept(...pos1,grad1)),2)+Math.pow(pos1[1]-similtaniouseY(returnYIntercept(...pos1,grad1),intercept2,grad1,grad2),2))
        }

        function drawSquare(x1,y1,x2,y2,x3,y3,x4,y4,colour = "rgba(100,100,100,1)",borderwidth = 0,bordercolour = "rgba(0,0,0,0)"){
          if(Math.random() < 0.001) {
            returnDistanceBetweenIntercepts();

          }
          ctx.strokeStyle = bordercolour;
          ctx.fillStyle = colour;
          ctx.lineWidth = borderwidth*cameraOffset.scale;
          ctx.beginPath();
          ctx.moveTo(x1,y1);
          ctx.lineTo(x2,y2);
          ctx.lineTo(x3,y3);
          ctx.lineTo(x4,y4);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        }
      </script>
    </canvas>
  </div>
</body>

</html>

<style>
  html{
    background-color: black;
  }

</style>
